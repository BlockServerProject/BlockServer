package org.blockserver.level;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.blockserver.Server;
import org.blockserver.blocks.Block;
import org.blockserver.blocks.BlockType;
import org.blockserver.blocks.UnknownBlockException;
import org.blockserver.entity.Entity;
import org.blockserver.level.generator.Generator;
import org.blockserver.level.provider.ChunkPosition;
import org.blockserver.level.provider.IChunk;
import org.blockserver.level.provider.LevelCorruptedException;
import org.blockserver.level.provider.LevelProvider;
import org.blockserver.math.Vector3;
import org.blockserver.math.Vector3d;
import org.blockserver.utility.Gettable;

public class Level{
	public final static EntityValidate validateInstance = new Level.DummyValidate();

	private String name;
	private long seed;
	private int defaultGamemode;
	private Vector3d spawnPos;
	private List<Entity> loadedEntities = new ArrayList<Entity>(0);
	private LevelProvider provider;
	private Server server;
	private Generator generator;

	/**
	 * Constructs a new Level with the format provided by <code>provider</code> and chunks
	 * generated by <code>generator</code>.
	 * @param name
	 * @param provider
	 * @param generator - the {@link Generator} to generate
	 *     chunks with, or <code>null</code> for the default generator from {@link Server#getDefaultLevelGenerator()}.
	 * @throws LevelCorruptedException
	 */
	public Level(String name, LevelProvider provider, Generator generator) throws LevelCorruptedException{
		this.name = name;
		this.provider = provider;
		this.generator = generator;
		init();
	}
//	public Level(String name, long seed, int defaultGamemode, Vector3d spawnPos, LevelProvider provider, Server server){
//		this(name, seed, defaultGamemode, spawnPos, provider, server, server.getWorldsDir());
//	}
//	public Level(String name, long seed, int defaultGamemode, Vector3d spawnPos, LevelProvider provider, Server server, File worldsDir) throws LevelCorruptedException{
//		this.name = name;
//		worldDir = new File(worldsDir, name);
//		worldDir.mkdirs();
//		this.seed = seed;
//		this.defaultGamemode = defaultGamemode;
//		this.spawnPos = spawnPos;
//		this.provider = provider;
//		this.server = server;
//		initialize();
//	}
//	public Level(LevelProvider provider) throws LevelCorruptedException{
//		this.provider = provider;
//		initialize();
//	}
	private void init() throws LevelCorruptedException{
		provider.init(new Gettable<Generator>(){
			public Generator get(){
				return getGenerator();
			}
		});
		/*
		new Thread(new Runnable(){
			@Override
			public void run(){
				Vector3d spawn = provider.getSpawn();
				ChunkPosition chunk = ChunkPosition.fromCoords(spawn.getX(), spawn.getZ());
				load(chunk);
			}
			private void load(ChunkPosition chunk){
				if(!provider.isChunkLoaded(chunk)){
					provider.loadChunk(chunk);
				}
			}
		}).start();
		*/
	}

	public String getName(){
		return name;
	}
	public Generator getGenerator(){
		if(generator == null){
			try{
				generator = server.getGeneratorMgr().generate(
						server.getDefaultLevelGenerator().getSimpleName(), provider,
						seed, new Random(), 0, "");
			}
			catch(Throwable e){
				e.printStackTrace();
				return null;
			}
		}
		return generator;
	}

	public Block getBlock(int x, int y, int z){
		ChunkPosition pos = ChunkPosition.fromCoords(x, z);
		IChunk chunk = provider.getChunk(pos);
		if(chunk != null){
			byte id = chunk.getBlock((byte) x, (byte) y, (byte) z);
			byte damage = chunk.getDamage((byte) x, (byte) y, (byte) z);
			try{
				return new Block(BlockType.getByID(id, damage));
			}
			catch(UnknownBlockException e){
				// e.printStackTrace();
				return new Block("Unknown", id, damage);
			}
		}
		return null;
	}
	public boolean setBlock(Vector3 coords, Block block){
		ChunkPosition pos = ChunkPosition.fromCoords(coords);
		IChunk chunk = provider.getChunk(pos);
		if(chunk == null){
			return false;
		}
		chunk.setBlock(coords.getChunkX(), coords.getChunkY(), coords.getChunkZ(), (byte) block.getID());
		chunk.setDamage(coords.getChunkX(), coords.getChunkY(), coords.getChunkZ(), (byte) block.getDamage());
		return true;
	}

	public double getGravityAt(Vector3 coords){
		return 9.8; // Earth gravitational constant; not sure if same for Minecraft ;)
	}

	public long getSeed() {
		return seed;
	}
	public void setSeed(long seed) {
		this.seed = seed;
	}

	public int getDefaultGamemode() {
		return defaultGamemode;
	}
	public void setDefaultGamemode(int gamemode) {
		defaultGamemode = gamemode;
	}

	public Vector3d getSpawnPos() {
		return spawnPos;
	}
	public void setSpawnPos(Vector3d spawnPos) {
		this.spawnPos = spawnPos;
	}

	public LevelProvider getLevelProvider(){
		return provider;
	}
	public Server getServer(){
		return server;
	}

	public Entity[] getEntities(){
		return (Entity[]) loadedEntities.toArray();
	}
	public Entity[] getEntities(Vector3d center, double radius){
		return getEntities(center, radius, validateInstance);
	}
	public Entity[] getEntities(Vector3d center, double radius, EntityValidate v){
		List<Entity> ret = new ArrayList<Entity>();
		for(Entity ent: loadedEntities){
			if(ent.distance(center) <= radius){
				if(v.isValid(ent)){
					ret.add(ent);
				}
			}
		}
		return (Entity[]) ret.toArray();
	}
	public Entity getClosestEntity(Vector3d center){
		return getClosestEntity(center, validateInstance);
	}
	public Entity getClosestEntity(Vector3d center, EntityValidate v){
		Entity ret = null;
		double currentDelta = Double.MAX_VALUE;
		for(Entity ent: loadedEntities){
			double distance = ent.distance(center);
			if(distance < currentDelta){
				if(v.isValid(ent)){
					currentDelta = distance;
					ret = ent;
				}
			}
		}
		return ret;
	}

	public static interface EntityValidate{
		public boolean isValid(Entity ent);
	}

	public static class DummyValidate implements EntityValidate{
		public boolean isValid(Entity ent){
			return true;
		}
	}
}
